@startuml
title 사용자 인증 (로그인/소셜로그인) 시퀀스 다이어그램

actor "게스트" as Guest
participant "AuthController" as Controller
participant "AuthenticationService" as AuthService
participant "JwtTokenProvider" as JwtProvider
participant "UserRepository" as UserRepo
participant "CacheService" as CacheService
participant "AuditService" as AuditService
database "Database" as DB
database "Cache" as Cache
actor "OAuthProvider" as OAuthProvider

== 일반 로그인 ==
Guest -> Controller: POST /api/auth/login\n{\n  "email": "user@example.com",\n  "password": "password123"\n}
activate Controller

Controller -> Controller: validateLoginRequest(loginRequest)
note right: 이메일/비밀번호 필수 필드 검증

Controller -> AuthService: login(email, password)
activate AuthService

== 사용자 조회 및 인증 ==
AuthService -> UserRepo: findByEmail(email)
activate UserRepo
UserRepo -> DB: SELECT * FROM user WHERE email = ?
alt 사용자 존재
    DB --> UserRepo: user data
    UserRepo --> AuthService: Optional<User>
else 사용자 없음
    DB --> UserRepo: empty result
    UserRepo --> AuthService: Optional.empty()
    AuthService --> Controller: InvalidCredentialsException
    Controller --> Guest: 401 Unauthorized\n{error: "invalid credentials"}
end
deactivate UserRepo

== 계정 상태 검증 ==
AuthService -> AuthService: validateUserStatus(user)
alt 계정 정지 상태
    AuthService --> Controller: AccountSuspendedException
    Controller --> Guest: 403 Forbidden\n{\n  "error": "account suspended",\n  "suspendedUntil": "2024-09-01T00:00:00Z",\n  "reason": "policy violation"\n}
else 이메일 미인증 상태 (정책에 따라)
    AuthService --> Controller: EmailNotVerifiedException
    Controller --> Guest: 403 Forbidden\n{error: "email verification required"}
end

== 비밀번호 검증 ==
AuthService -> AuthService: verifyPassword(inputPassword, storedHashedPassword)
note right: BCrypt.checkpw() 등을 사용한\n해시 비밀번호 검증

alt 비밀번호 불일치
    AuthService -> AuthService: incrementFailedAttempts(userId)
    note right: 로그인 시도 실패 카운터 증가

    AuthService -> CacheService: recordFailedAttempt(email, clientIP)
    activate CacheService
    CacheService -> Cache: INCR login_attempts:{email}:{ip}
    CacheService -> Cache: EXPIRE login_attempts:{email}:{ip} 3600
    deactivate CacheService

    AuthService --> Controller: InvalidCredentialsException
    Controller --> Guest: 401 Unauthorized\n{error: "invalid credentials"}
end

== 로그인 시도 횟수 제한 확인 ==
AuthService -> CacheService: getFailedAttempts(email, clientIP)
activate CacheService
CacheService -> Cache: GET login_attempts:{email}:{ip}
alt 시도 횟수 초과 (5회 이상)
    CacheService --> AuthService: attemptCount > 5
    AuthService --> Controller: TooManyAttemptsException
    Controller --> Guest: 429 Too Many Requests\n{\n  "error": "too many failed attempts",\n  "retryAfter": 3600\n}
end
deactivate CacheService

== JWT 토큰 생성 ==
AuthService -> JwtProvider: generateAccessToken(userId, userRole)
activate JwtProvider
JwtProvider -> JwtProvider: createTokenClaims(userId, role, expirationTime)
JwtProvider -> JwtProvider: signToken(claims, secretKey)
JwtProvider --> AuthService: accessToken
deactivate JwtProvider

AuthService -> JwtProvider: generateRefreshToken(userId)
activate JwtProvider
JwtProvider --> AuthService: refreshToken
deactivate JwtProvider

== 로그인 세션 관리 ==
AuthService -> CacheService: storeUserSession(userId, sessionInfo)
activate CacheService
CacheService -> Cache: SET user_session:{userId} {sessionInfo} TTL=7d
note right: 세션 정보: 로그인 시간, IP, User-Agent 등
deactivate CacheService

== 로그인 실패 횟수 초기화 ==
AuthService -> CacheService: clearFailedAttempts(email, clientIP)
CacheService -> Cache: DEL login_attempts:{email}:{ip}

== 마지막 로그인 시간 업데이트 ==
AuthService -> UserRepo: updateLastLoginAt(userId, now())
UserRepo -> DB: UPDATE user SET last_login_at = NOW() WHERE id = ?

== 감사 로그 기록 ==
AuthService -> AuditService: logSuccessfulLogin(userId, clientIP, userAgent)
activate AuditService
AuditService -> DB: INSERT INTO audit_log\n(event_type, user_id, ip_address, user_agent, created_at)
deactivate AuditService

AuthService --> Controller: LoginResult\n{accessToken, refreshToken, user}
deactivate AuthService

Controller --> Guest: 200 OK\n{\n  "accessToken": "eyJ...",\n  "refreshToken": "eyJ...",\n  "tokenType": "Bearer",\n  "expiresIn": 3600,\n  "user": {\n    "id": 12345,\n    "email": "user@example.com",\n    "nickname": "닉네임",\n    "profileImageUrl": "https://..."\n  }\n}
deactivate Controller

== 소셜 로그인 (OAuth) ==
Guest -> Controller: POST /api/auth/social-login\n{\n  "provider": "google",\n  "accessToken": "oauth_access_token"\n}
activate Controller

Controller -> AuthService: socialLogin(provider, oauthToken)
activate AuthService

== OAuth 토큰 검증 ==
AuthService -> OAuthProvider: validateToken(accessToken)
activate OAuthProvider
OAuthProvider -> OAuthProvider: verifyTokenSignature(accessToken)
OAuthProvider -> OAuthProvider: checkTokenExpiration(accessToken)
alt 유효한 토큰
    OAuthProvider --> AuthService: OAuthUserInfo\n{email, name, profileImage}
else 무효한 토큰
    OAuthProvider --> AuthService: InvalidTokenException
    AuthService --> Controller: OAuthException
    Controller --> Guest: 401 Unauthorized\n{error: "invalid oauth token"}
end
deactivate OAuthProvider

== 기존 사용자 확인 또는 생성 ==
AuthService -> UserRepo: findByEmail(oauthUserInfo.email)
activate UserRepo
UserRepo -> DB: SELECT * FROM user WHERE email = ?
alt 기존 사용자 존재
    DB --> UserRepo: existing user
    UserRepo --> AuthService: Optional<User>

    == OAuth 계정 연동 정보 업데이트 ==
    AuthService -> AuthService: updateOAuthInfo(user, provider, oauthUserId)
    AuthService -> UserRepo: save(updatedUser)
    UserRepo -> DB: UPDATE user SET oauth_provider = ?, oauth_id = ?

else 신규 사용자 (첫 소셜 로그인)
    DB --> UserRepo: empty
    UserRepo --> AuthService: Optional.empty()
    deactivate UserRepo

    == 소셜 계정으로 자동 회원가입 ==
    AuthService -> AuthService: createUserFromOAuth(oauthUserInfo, provider)
    note right: - 이메일, 닉네임은 OAuth에서 가져옴\n- 프로필 이미지 URL 설정\n- 이메일 인증 완료 상태로 생성

    AuthService -> UserRepo: save(newSocialUser)
    activate UserRepo
    UserRepo -> DB: INSERT INTO user\n(email, nickname, profile_image_url, oauth_provider, oauth_id, status, email_verified_at)
    DB --> UserRepo: new_user_id
    UserRepo --> AuthService: newUser
    deactivate UserRepo

    == 소셜 가입 환영 알림 ==
    AuthService -> AuthService: sendSocialWelcomeNotification(newUser.id)
end

== JWT 토큰 생성 (소셜 로그인) ==
AuthService -> JwtProvider: generateAccessToken(user.id, user.role)
JwtProvider --> AuthService: accessToken

AuthService -> JwtProvider: generateRefreshToken(user.id)
JwtProvider --> AuthService: refreshToken

== 세션 및 로그 처리 ==
AuthService -> CacheService: storeUserSession(user.id, sessionInfo)
CacheService -> Cache: SET user_session:{userId} {sessionInfo}

AuthService -> AuditService: logSocialLogin(user.id, provider, clientIP)
AuditService -> DB: INSERT INTO audit_log

AuthService --> Controller: SocialLoginResult\n{accessToken, refreshToken, user, isNewUser}
deactivate AuthService

Controller --> Guest: 200 OK\n{\n  "accessToken": "eyJ...",\n  "refreshToken": "eyJ...",\n  "user": {...},\n  "isNewUser": true\n}
deactivate Controller

== 토큰 갱신 ==
Guest -> Controller: POST /api/auth/refresh\n{\n  "refreshToken": "eyJ..."\n}
activate Controller

Controller -> AuthService: refreshToken(refreshToken)
activate AuthService

AuthService -> JwtProvider: validateRefreshToken(refreshToken)
activate JwtProvider
alt 유효한 리프레시 토큰
    JwtProvider -> JwtProvider: verifyTokenSignature(refreshToken)
    JwtProvider -> JwtProvider: extractUserId(refreshToken)
    JwtProvider --> AuthService: userId
else 무효한 리프레시 토큰
    JwtProvider --> AuthService: InvalidTokenException
    AuthService --> Controller: InvalidTokenException
    Controller --> Guest: 401 Unauthorized\n{error: "invalid refresh token"}
end
deactivate JwtProvider

AuthService -> CacheService: validateUserSession(userId)
activate CacheService
CacheService -> Cache: GET user_session:{userId}
alt 세션 존재
    CacheService --> AuthService: sessionInfo
else 세션 없음 (로그아웃됨)
    CacheService --> AuthService: null
    AuthService --> Controller: SessionExpiredException
    Controller --> Guest: 401 Unauthorized\n{error: "session expired"}
end
deactivate CacheService

== 새 액세스 토큰 발급 ==
AuthService -> JwtProvider: generateAccessToken(userId, userRole)
JwtProvider --> AuthService: newAccessToken

AuthService --> Controller: RefreshResult{newAccessToken}
deactivate AuthService

Controller --> Guest: 200 OK\n{\n  "accessToken": "eyJ...",\n  "tokenType": "Bearer",\n  "expiresIn": 3600\n}
deactivate Controller

== 로그아웃 ==
Guest -> Controller: POST /api/auth/logout
activate Controller

Controller -> AuthService: logout(userId)
activate AuthService

== 세션 무효화 ==
AuthService -> CacheService: invalidateUserSession(userId)
activate CacheService
CacheService -> Cache: DEL user_session:{userId}
deactivate CacheService

== 리프레시 토큰 블랙리스트 등록 ==
AuthService -> CacheService: blacklistToken(refreshToken)
CacheService -> Cache: SET blacklisted_token:{tokenId} true TTL=7d

AuthService -> AuditService: logLogout(userId, clientIP)
AuditService -> DB: INSERT INTO audit_log

AuthService --> Controller: logout success
deactivate AuthService

Controller --> Guest: 200 OK\n{message: "logged out successfully"}
deactivate Controller

== 예외 처리 ==
alt 잘못된 자격 증명
    AuthService --> Controller: InvalidCredentialsException
    Controller --> Guest: 401 Unauthorized\n{error: "invalid credentials"}
else 계정 정지
    AuthService --> Controller: AccountSuspendedException
    Controller --> Guest: 403 Forbidden\n{error: "account suspended"}
else 로그인 시도 횟수 초과
    AuthService --> Controller: TooManyAttemptsException
    Controller --> Guest: 429 Too Many Requests\n{error: "too many attempts"}
else OAuth 토큰 오류
    OAuthProvider --> AuthService: OAuthException
    AuthService --> Controller: OAuthException
    Controller --> Guest: 401 Unauthorized\n{error: "oauth authentication failed"}
end

@enduml
